# Project Source Folder
This folder contains all the design source files written in System Verilog.
The hierarchy is as follows:

## Top level module wrapper generator: mvau_top/gen_mvau_top.py
The top level module is a wrapper generated by a python script. This helps in keeping the parameters programmable.
This scripts generates a Verilog wrapper (instead of SystemVerilog). This is due to IP generation of needs of Vivado which 
needs a Verilog top level file. It is called by saying:
```
python gen_mvau_top.py --kdim <k> --inp_wl <i> --inp_bin <ib> --ifm_ch <ifm> --ofm_ch <ofm> --ifm_dim <ifmd> --wgt_wl <w> --wgt_bin <wb> --out_wl <o> --simd <s> --pe <p>
```
where
* `kdim`: Kernel dimension
* `inp_wl`: Input word length
* `inp_bin`: '1' if input is binary, '0' if not
* `ifm_ch`: Number of input feature map channels
* `ofm_ch`: Number of output feature map channels
* `ifm_dim`: Input feature map dimension
* `wgt_wl`: Weight precision
* `wgt_bin`: '1' if weights are binary, '0' if not
* `out_wl`: Output word length
* `simd`: SIMD factor
* `pe`: PE factor

The file generated is named `mvau_top.v` and essentially instantiates the `mvau.sv` module.

## Top level module: mvau_top/mvau.sv
This is the top level design unit which instantiates a number of blocks.
The main block is the matrix vector computation unit which multiplies
the input activation and weight matrix. The multiplication is carried
out in steps, with each step multiplying a weight tile of dimension SIMDxPE,
where each tile has a word length of TW, with a slice of input
activation vector of length SIMD. The top level file generates the required
control signals to generate the weight tile and input activation vector slice.

### Threshold based Activation Unit: mvau_top/mvau_act_comp.sv
The activation unit is not implemented yet and this file only acts as a placeholder

### Control Block: mvau_top/mvau_control_block.sv
This control block controls reading from the weight memory. It generates the read address
for the weight memory.

### Weight memory top: mvau_top/gen_mvau_weight_mem_mreged.py
A python based generator of top level weight memory which instantiates a number of weight memories
depending on number of processing elements

### Weight memories: mvau_top/gen_mvau_weight_mem.py
A python based generator of weight memories which is a simple ROM whose contents are read 
from a hex file generated by a python script. A number of these weight memories are instantiated by 
mvau_weight_mem_merged.sv. The number of memories equals PE and the width of each word equals SIMDxTW.

## Stream Top level module wrapper generator: mvau_top/mvau_stream/gen_mvau_stream_top.py
The top level module is a wrapper generated by a python script for the stream unit. It is not used in the Batch implementation.
This helps in keeping the parameters programmable. This scripts generates a Verilog wrapper (instead of SystemVerilog). This is due to IP generation of needs of Vivado which needs a Verilog top level file. It is called by saying:
```
python gen_mvau_stream_top.py --kdim <k> --inp_wl <i> --inp_bin <ib> --ifm_ch <ifm> --ofm_ch <ofm> --ifm_dim <ifmd> --wgt_wl <w> --wgt_bin <wb> --out_wl <o> --simd <s> --pe <p>
```
where
* `kdim`: Kernel dimension
* `inp_wl`: Input word length
* `inp_bin`: '1' if input is binary, '0' if not
* `ifm_ch`: Number of input feature map channels
* `ofm_ch`: Number of output feature map channels
* `ifm_dim`: Input feature map dimension
* `wgt_wl`: Weight precision
* `wgt_bin`: '1' if weights are binary, '0' if not
* `out_wl`: Output word length
* `simd`: SIMD factor
* `pe`: PE factor

The file generated is named `mvau_stream_top.v` and essentially instantiates the `mvau_stream.sv` module.

### Matrix vector stream unit: mvau_top/mvau_stream/mvau_stream.sv  
This unit is the main computation unit performing multiply accumulate of a
stream of weight and a slice of input activation unit. It uses PE numbers of
processing elements. Each processing element implements the dot product of
its corresponding row of the weight tile with the input activation vector slice.

#### MVAU Stream Control Block: mvau_top/mvau_stream/mvau_stream_control_block.sv
This control block controls reading to and writing from the input buffer. It generates
the address and read/write enables for the input buffer. It also implements a state machine
to control generation of various control signals to adhere to the AXI stream protocol for I/O

#### Input Buffer: mvau_top/mvau_stream/mvau_inp_buffer.sv
This unit stores one column of input feature map as it is multiplied
with multiple rows of the weight matrix. During the first SIMDxSF clock
cycles, the input buffer is written with new elements of the input feature
map and for the next SIMDx(NF-1) clock cycles, the input buffer is re-used
for other computations.

#### Processing element design unit: mvau_top/mvau_stream/mvu_pe/mvu_pe.sv
The processing elements consists of a number of SIMD blocks which perform
multiplication between a single weight and input activation. There are
three types of SIMD blocks based on the input word length of weights and
input activations but only one is implemented using generate statements. 

The output of SIMD is connected to an adder tree which if both the inputs
are 1-bit reduces to a popcount (counting number of '1's in the SIMD's output.

##### SIMD design unit: mvau_top/mvau_stream/mvu_pe/mvu_pe_simd_\<type\>.sv
The three different SIMD blocks are
- mvu_pe_simd_std.sv: Implements a 2's complement multiplication
- mvu_pe_simd_binary.sv: If one of the two inputs is 1-bit, a '0' is
interpreted as -1 and '1' is interpreted as +1, meaning the output will
either be a copy of the other input or a 2's complement of it
- mvu_pe_simd_xnor.sv: If both inputs are 1-bit, the output is an XNOR
of the two inputs. This implements an XNOR network.

##### Adder Tree: mvau_top/mvau_stream/mvu_pe/mvu_pe_\<adders/popcount\>.sv
The output of the SIMD blocks are added together either using an adder
tree or a popcount (when both weights and input activation are 1-bit).
A simple for-loop based implementation is selection (at the moment) for
simplicity, so both design files are identical.

##### Accumulator: mvau_top/mvau_stream/mvu_pe/mvu_pe_acc.sv
A simple accumulator. The accumulator is resetted every Matrix/SIMD cycles.
		 
